import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.CEHkq4dy.js";const y=JSON.parse('{"title":"TypeScript中type和interface的至关重要的区别","description":"深入分析 TypeScript 中 type 和 interface 的核心区别，包括扩展方式、合并声明、使用场景等关键差异","frontmatter":{"title":"TypeScript中type和interface的至关重要的区别","description":"深入分析 TypeScript 中 type 和 interface 的核心区别，包括扩展方式、合并声明、使用场景等关键差异","date":"2025-01-20T00:00:00.000Z","tags":["TypeScript","类型系统","前端开发","JavaScript","编程基础"],"keywords":"TypeScript,type,interface,类型定义,类型系统,TypeScript区别,前端开发","author":"lufbduk","category":"技术笔记","head":[["meta",{"name":"keywords","content":"TypeScript,type,interface,类型定义,类型系统,TypeScript区别,前端开发,JavaScript"}],["meta",{"property":"og:title","content":"TypeScript中type和interface的至关重要的区别 - 类型系统深度解析"}],["meta",{"property":"og:description","content":"深入分析 TypeScript 中 type 和 interface 的核心区别，包括扩展方式、合并声明、使用场景等关键差异"}]]},"headers":[],"relativePath":"ai-tech-notes/TypeScript中type和interface的至关重要的区别.md","filePath":"ai-tech-notes/TypeScript中type和interface的至关重要的区别.md","lastUpdated":1749284282000}'),e={name:"ai-tech-notes/TypeScript中type和interface的至关重要的区别.md"};function h(p,s,l,k,r,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="typescript-中-type-和-interface-的区别" tabindex="-1">TypeScript 中 type 和 interface 的区别 <a class="header-anchor" href="#typescript-中-type-和-interface-的区别" aria-label="Permalink to &quot;TypeScript 中 type 和 interface 的区别&quot;">​</a></h1><blockquote><p><strong>摘要</strong>：TypeScript 中的 <code>type</code> 和 <code>interface</code> 都可以定义类型，但在扩展方式、合并声明、使用场景等方面存在重要区别。本文将详细对比两者的差异，帮助开发者选择合适的类型定义方式。</p></blockquote><p>ts 的 type 和 interface 有什么至关重要的区别吗</p><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>TypeScript 中的 <code>type</code> 和 <code>interface</code> 都可以用来定义类型，但它们有一些关键区别：</p><h2 id="主要区别" tabindex="-1">主要区别 <a class="header-anchor" href="#主要区别" aria-label="Permalink to &quot;主要区别&quot;">​</a></h2><ol><li><p><strong>扩展方式不同</strong></p><ul><li><code>interface</code> 使用 <code>extends</code> 继承：<div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li><li><code>type</code> 使用交叉类型 <code>&amp;</code>：<div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li></ul></li><li><p><strong>合并声明</strong></p><ul><li><code>interface</code> 可以重复声明并自动合并：<div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 最终 User 为 { name: string; age: number }</span></span></code></pre></div></li><li><code>type</code> 不能重复声明，会报错</li></ul></li><li><p><strong>实现类</strong></p><ul><li><code>interface</code> 可以被类实现 (<code>implements</code>)</li><li><code>type</code> 不能直接被类实现（除非是对象类型或交叉类型）</li></ul></li><li><p><strong>灵活性</strong></p><ul><li><code>type</code> 可以定义更复杂的类型：<div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringOrNumber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NonNullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> never</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span></span></code></pre></div></li></ul></li></ol><h2 id="使用建议" tabindex="-1">使用建议 <a class="header-anchor" href="#使用建议" aria-label="Permalink to &quot;使用建议&quot;">​</a></h2><ul><li><p><strong>使用 interface</strong> 当：</p><ul><li>需要声明合并</li><li>定义对象类型且可能被类实现</li><li>与面向对象编程模式配合</li></ul></li><li><p><strong>使用 type</strong> 当：</p><ul><li>需要联合类型、元组等复杂类型</li><li>需要实用工具类型或条件类型</li><li>定义简单类型别名</li></ul></li></ul><p>在大多数情况下，它们可以互换使用，选择主要取决于团队约定和个人偏好。</p><p>我说的是至关重要的区别</p><p>你问的是<strong>至关重要的区别</strong>，也就是真正影响开发体验和类型系统能力的核心差异。以下是 TypeScript 中 <code>type</code> 和 <code>interface</code> 最关键的区别：</p><hr><h3 id="_1-声明合并-declaration-merging-——-interface-独有" tabindex="-1"><strong>1. 声明合并（Declaration Merging）—— interface 独有</strong> <a class="header-anchor" href="#_1-声明合并-declaration-merging-——-interface-独有" aria-label="Permalink to &quot;**1. 声明合并（Declaration Merging）—— interface 独有**&quot;">​</a></h3><p><strong><code>interface</code> 可以重复声明并自动合并，而 <code>type</code> 会报错。</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 自动合并成 { name: string; age: number }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ Error: Duplicate identifier &#39;Person&#39;</span></span></code></pre></div><p><strong>为什么至关重要？</strong></p><ul><li>这个特性让 <code>interface</code> 在<strong>扩展第三方库类型</strong>（如 <code>Window</code>、<code>React.ComponentProps</code>）时非常有用。</li><li><code>type</code> 无法做到这一点，强行扩展只能用 <code>&amp;</code> 交叉类型，但可能导致意外行为。</li></ul><hr><h3 id="_2-type-能表达更复杂的类型" tabindex="-1"><strong>2. <code>type</code> 能表达更复杂的类型</strong> <a class="header-anchor" href="#_2-type-能表达更复杂的类型" aria-label="Permalink to &quot;**2. \`type\` 能表达更复杂的类型**&quot;">​</a></h3><p><strong><code>type</code> 可以定义联合类型、元组、条件类型、映射类型等，而 <code>interface</code> 不能。</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 联合类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 元组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 条件类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;b&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 映射类型</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// interface 无法直接表达这些</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误</span></span></code></pre></div><p><strong>为什么至关重要？</strong></p><ul><li>如果你需要<strong>高级类型操作</strong>（如 <code>Partial&lt;T&gt;</code>、<code>Pick&lt;T, K&gt;</code>、<code>Omit&lt;T, K&gt;</code>），必须用 <code>type</code>。</li><li><code>interface</code> 只能描述对象结构，无法表达逻辑运算。</li></ul><hr><h3 id="_3-interface-可以被类-implements-type-不行-除非是对象类型" tabindex="-1"><strong>3. <code>interface</code> 可以被类 <code>implements</code>，<code>type</code> 不行（除非是对象类型）</strong> <a class="header-anchor" href="#_3-interface-可以被类-implements-type-不行-除非是对象类型" aria-label="Permalink to &quot;**3. \`interface\` 可以被类 \`implements\`，\`type\` 不行（除非是对象类型）**&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dog</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Dog&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {} }  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AnimalType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Cat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AnimalType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Cat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {} }  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅（但仅限于对象类型）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NotAnObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NotAnObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 无法实现联合类型</span></span></code></pre></div><p><strong>为什么至关重要？</strong></p><ul><li>如果你写 <strong>OOP 风格的代码</strong>（类 + 接口），<code>interface</code> 更符合传统设计模式。</li><li><code>type</code> 只有在描述对象结构时才能被 <code>implements</code>，其他情况（如联合类型）不行。</li></ul><hr><h3 id="_4-性能差异-极端情况下" tabindex="-1"><strong>4. 性能差异（极端情况下）</strong> <a class="header-anchor" href="#_4-性能差异-极端情况下" aria-label="Permalink to &quot;**4. 性能差异（极端情况下）**&quot;">​</a></h3><ul><li><strong><code>interface</code> 在类型检查时可能更快</strong>，因为 TS 会对同名 <code>interface</code> 做合并缓存。</li><li><strong><code>type</code> 在复杂类型（如大联合类型）时可能稍慢</strong>，因为每次都要重新计算。</li></ul><p><strong>为什么至关重要？</strong></p><ul><li>在<strong>超大型项目</strong>或<strong>性能敏感场景</strong>下，<code>interface</code> 可能更优（但差异通常很小）。</li></ul><hr><h3 id="终极结论-什么时候用哪个" tabindex="-1"><strong>终极结论：什么时候用哪个？</strong> <a class="header-anchor" href="#终极结论-什么时候用哪个" aria-label="Permalink to &quot;**终极结论：什么时候用哪个？**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>场景</strong></th><th><strong>推荐</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>需要扩展第三方类型</strong>（如 <code>Window</code>）</td><td><code>interface</code></td><td>支持声明合并</td></tr><tr><td><strong>需要联合类型、条件类型、映射类型</strong></td><td><code>type</code></td><td><code>interface</code> 无法表达</td></tr><tr><td><strong>类需要 <code>implements</code></strong></td><td><code>interface</code></td><td>更符合 OOP 习惯</td></tr><tr><td><strong>简单的对象类型</strong></td><td>都可以</td><td>无本质区别</td></tr><tr><td><strong>性能优化（极端情况）</strong></td><td><code>interface</code></td><td>可能更快</td></tr></tbody></table><p><strong>如果只记一点：</strong></p><ul><li><strong><code>interface</code> 适合对象结构 + 可扩展性</strong>（如 React Props、API 响应类型）。</li><li><strong><code>type</code> 适合复杂类型逻辑</strong>（如联合类型、工具类型）。</li></ul>`,39)]))}const o=i(e,[["render",h]]);export{y as __pageData,o as default};
